# StreamDeck Integration Design Document

**Project:** AC Tools Content Manager  
**Component:** UI Observer with StreamDeck Navigation  
**Version:** 1.0  
**Date:** December 2025  
**Target Framework:** .NET Framework 4.5.2

---

## Table of Contents

1. [Overview](#overview)
2. [Architecture](#architecture)
3. [Key Components](#key-components)
4. [Communication Protocol](#communication-protocol)
5. [State Management](#state-management)
6. [Navigation System](#navigation-system)
7. [Implementation Details](#implementation-details)
8. [Error Handling & Reliability](#error-handling--reliability)
9. [Performance Considerations](#performance-considerations)
10. [Testing Strategy](#testing-strategy)
11. [Future Enhancements](#future-enhancements)

---

## Overview

### Purpose

The StreamDeck integration enables Content Manager's UI navigation through a StreamDeck hardware controller. Users can navigate the application UI, interact with controls, and perform actions using physical buttons on the StreamDeck.

### Goals

- **Seamless Integration**: StreamDeck buttons reflect current UI state
- **Automatic Discovery**: UI elements automatically become navigable
- **State Replication**: Automatic recovery from disconnections
- **Fire-and-Forget API**: No error handling required by callers
- **Zero Configuration**: Works out of the box with default settings

### Non-Goals

- Supporting multiple StreamDecks simultaneously
- Real-time UI rendering on StreamDeck display
- Custom scripting or macro language
- Integration with game telemetry during races

---

## Architecture

### High-Level Overview

```
???????????????????????????????????????????????????????????????????
?                     Content Manager (WPF)                        ?
?  ?????????????????????????????????????????????????????????????  ?
?  ?                  UI Observer System                       ?  ?
?  ?  ??????????????  ????????????  ?????????????????????    ?  ?
?  ?  ?  Navigator ???? NavGraph ???? SDPClient (Pipe)  ????????????
?  ?  ??????????????  ????????????  ?????????????????????    ?  ?  ?
?  ?        ?              ?                                   ?  ?  ?
?  ?  ??????????????  ????????????                           ?  ?  ?
?  ?  ?  NavNodes  ?  ? PathFilter?                           ?  ?  ?
?  ?  ??????????????  ????????????                           ?  ?  ?
?  ?????????????????????????????????????????????????????????  ?  ?
?                           ?                                   ?  ?
?  ?????????????????????????????????????????????????????????  ?  ?
?  ?                 WPF Visual Tree                        ?  ?  ?
?  ?  (MainWindow, Buttons, Sliders, Menus, etc.)          ?  ?  ?
?  ?????????????????????????????????????????????????????????  ?  ?
???????????????????????????????????????????????????????????????????  ?
                                                                      ?
                      Named Pipe: NWRS_AC_SDPlugin_Pipe             ?
                                                                      ?
???????????????????????????????????????????????????????????????????  ?
?              NWRS AC StreamDeck Plugin (C#)                      ????
?  ?????????????????????????????????????????????????????????????  ?
?  ?  Named Pipe Server  ?  Command Processor  ?  VKey/VPage  ?  ?
?  ?????????????????????????????????????????????????????????????  ?
?                           ?                                       ?
?  ?????????????????????????????????????????????????????????????  ?
?  ?          Elgato StreamDeck SDK (WebSocket)                ?  ?
?  ?????????????????????????????????????????????????????????????  ?
???????????????????????????????????????????????????????????????????
                           ?
???????????????????????????????????????????????????????????????????
?                   StreamDeck Hardware                            ?
?                   (15 physical buttons)                          ?
???????????????????????????????????????????????????????????????????
```

### Component Layers

**Layer 1: UI Discovery & Observation**
- `NavNode`: Represents navigable UI elements
- `NavGraph`: Manages navigation tree structure
- Path filtering and exclusion rules

**Layer 2: Navigation Logic**
- `Navigator`: Core navigation engine
- Focus management and movement
- Modal/group handling

**Layer 3: Communication**
- `SDPClient`: Named pipe client
- State replication
- Automatic reconnection

**Layer 4: Plugin Bridge**
- `NWRS AC SD Plugin`: Named pipe server
- Command processing
- StreamDeck SDK integration

---

## Key Components

### 1. Navigator (`Navigator.cs` + `Navigator.SD.cs`)

**Responsibilities:**
- Manage focus state
- Handle navigation commands (Up, Down, Left, Right)
- Mouse click simulation
- Modal stack management

**Key Features:**
```csharp
public class Navigator
{
    // StreamDeck integration
    private SDPClient _sdpClient;
    
    // Navigation state
    private NavNode _currentNode;
    private Stack<NavNode> _modalStack;
    
    // Key methods
    public void NavigateUp() { }
    public void NavigateDown() { }
    public void PerformMouseClick() { }
    public void HandleModalOpened(NavNode modalNode) { }
}
```

**StreamDeck Extension (`Navigator.SD.cs`):**
- Icon discovery and page setup
- Key definitions (Back, Up, Down, Left, Right, MouseLeft, etc.)
- Page switching based on control type
- Event handling for KeyPressed

---

### 2. NavNode (`NavNode.cs`)

**Responsibilities:**
- Wrap WPF UIElement for navigation
- Maintain parent-child relationships
- Track element properties (position, visibility, navigability)

**Structure:**
```csharp
public class NavNode
{
    public UIElement Element { get; }
    public NavNode Parent { get; }
    public List<NavNode> Children { get; }
    
    public bool IsGroup { get; }      // ListBox, Menu, etc.
    public bool IsModal { get; }      // Window, Dialog
    public bool IsNavigable { get; } // Button, Slider, etc.
    
    public Rect BoundsOnScreen { get; }
    public string SimpleName { get; }  // Type:Name
}
```

**Navigation Properties:**
- `IsGroup`: Can contain other navigable elements
- `IsModal`: Blocks navigation outside its scope
- `IsNavigable`: Can receive focus
- Parent-child hierarchy for scope resolution

---

### 3. SDPClient (`SDPClient.cs`)

**Responsibilities:**
- Named pipe communication with plugin
- Authoritative state management
- Automatic reconnection with exponential backoff
- Fire-and-forget command API

**Architecture Pattern: State Replication**

```csharp
public class SDPClient : IDisposable
{
    // ???????????????????????????????????????????????????????????
    // AUTHORITATIVE STATE (what SHOULD be on the plugin)
    // ???????????????????????????????????????????????????????????
    private readonly Dictionary<string, SDPKeyDef> _keys;
    private readonly Dictionary<string, SDPPageDef> _pages;
    private string _currentPage;
    
    // ???????????????????????????????????????????????????????????
    // FIRE-AND-FORGET API
    // ???????????????????????????????????????????????????????????
    public void DefineKey(string keyName, string title, string iconSpec) { }
    public void DefinePage(string pageName, string[][] keyGrid) { }
    public void SwitchPage(string pageName) { }
    
    // ???????????????????????????????????????????????????????????
    // AUTOMATIC STATE REPLICATION
    // ???????????????????????????????????????????????????????????
    private async Task ReplicateStateToPluginAsync()
    {
        // Phase 1: Send all keys
        // Phase 2: Send all pages (ordered by dependency)
        // Phase 3: Restore current page
    }
}
```

**Key Design Decisions:**

1. **Fire-and-Forget API**: No return values, no exceptions to handle
2. **Authoritative State**: CM owns the truth, plugin is a replica
3. **Automatic Recovery**: Disconnections handled transparently
4. **Ordered Replication**: Base pages sent before derived pages

---

### 4. NavGraph (`NavGraph.cs`)

**Responsibilities:**
- Build and maintain navigation tree from WPF visual tree
- Apply path filtering rules
- Discover modal boundaries
- Provide graph traversal utilities

**Key Methods:**
```csharp
public class NavGraph
{
    public NavNode RegisterRoot(FrameworkElement root);
    public void SyncRoot(NavNode root);
    public List<NavNode> GetNavigableDescendants(NavNode scope);
    public NavNode FindClosestInDirection(NavNode from, Direction dir);
}
```

---

## Communication Protocol

### Protocol Overview

**Transport:** Named Pipe (`NWRS_AC_SDPlugin_Pipe`)  
**Format:** Text-based, one command/event per line  
**Direction:** Bidirectional  
**Encoding:** UTF-8

### Commands (CM ? Plugin)

**1. DefineKey**
```
DefineKey <KeyName> [Title] [IconSpec]
```
- Creates reusable key definition
- Title and icon both optional (blank keys supported)
- Icon formats: absolute path, `!Text`, `data:image/...`, `null`

**2. DefinePage**
```
DefinePage <PageName>[:<BasePage>] <KeyGrid>
```
- Creates page with 5x3 key grid (JSON format)
- Supports inheritance: `ChildPage:ParentPage`
- Grid semantics:
  - `"KeyName"` = Use specific key
  - `"base"` = Inherit from parent page
  - `null` or `""` = Empty position

**3. SwitchPage**
```
SwitchPage <PageName>
```
- Changes active page on StreamDeck

### Events (Plugin ? CM)

**1. KeyPress**
```
KeyPress <KeyName>
```
- Sent when user presses button on StreamDeck

**2. KeyDefined** (Confirmation)
```
KeyDefined <KeyName> OK
KeyDefined <KeyName> ERROR <Message>
```

**3. PageDefined** (Confirmation)
```
PageDefined <PageName> OK
PageDefined <PageName> ERROR <Message>
```

### Protocol Example

```
# Initial Setup
CM  ? DefineKey Back null C:\CM\Icons\Back.png
Plugin ? KeyDefined Back OK

CM  ? DefineKey Up null C:\CM\Icons\Up.png
Plugin ? KeyDefined Up OK

# Create page
CM  ? DefinePage Navigation [["Back","Up",null],[null,null,null],...]
Plugin ? PageDefined Navigation OK

# Switch to page
CM  ? SwitchPage Navigation

# User interaction
Plugin ? KeyPress Back
```

---

## State Management

### Authoritative State Model

**Content Manager** is the **single source of truth**:
- CM maintains complete state (keys, pages, current page)
- Plugin is a **replica** that mirrors CM's state
- On connection/reconnection: CM replicates full state to plugin

### State Replication Process

```
Connection Established
        ?
?????????????????????????????????????????
?   Phase 1: Replicate Keys             ?
?   - Send DefineKey for each key       ?
?   - Wait for KeyDefined confirmations ?
?????????????????????????????????????????
        ?
?????????????????????????????????????????
?   Phase 2: Replicate Pages            ?
?   - Order pages by dependency          ?
?   - Base pages BEFORE derived pages    ?
?   - Send DefinePage for each page      ?
?   - Wait for PageDefined confirmations ?
?????????????????????????????????????????
        ?
?????????????????????????????????????????
?   Phase 3: Restore Current Page       ?
?   - Send SwitchPage to last active    ?
?   - User sees correct page immediately ?
?????????????????????????????????????????
        ?
   State Synced ?
```

### Page Dependency Ordering

**Problem:** Derived pages reference base pages that must exist first

**Solution:** Topological sort before replication

```csharp
private List<SDPPageDef> OrderPagesByDependency(List<SDPPageDef> pages)
{
    // Navigation ? sent first (no base)
    // Slider ? sent second (no base)
    // DoubleSlider:Slider ? sent AFTER Slider (depends on it)
    // RoundSlider:Slider ? sent AFTER Slider (depends on it)
}
```

### State Consistency Guarantees

1. **Atomic Replication**: All-or-nothing state transfer
2. **Idempotent Operations**: Redefining keys/pages is safe
3. **Queue Draining**: Pending commands sent after sync completes
4. **Connection Loss**: State preserved in CM, replicated on reconnect

---

## Navigation System

### Navigation Modes

**1. DirectionalNavigation**: Arrow key movement
- Find closest element in specified direction
- Uses geometric scoring (distance + alignment)
- Respects modal/group boundaries

**2. MouseClickSimulation**: Programmatic clicking
- Finds click target (control or label)
- Simulates mouse down/up at element center
- Works with buttons, checkboxes, menu items

**3. KeyboardInput**: Text entry (future)
- Virtual keyboard for filters
- StreamDeck as text input device

### Modal Stack Management

**Problem:** Dialogs and popups should restrict navigation

**Solution:** Modal stack with scope enforcement

```csharp
// Modal opened
modalStack.Push(dialogNode);
SwitchToPage(GetPageForControl(dialogNode));

// Navigation restricted to modal scope
var scope = modalStack.Peek() ?? rootNode;
var candidates = GetNavigableInScope(scope);

// Modal closed
modalStack.Pop();
SwitchToPage(GetPageForControl(parentNode));
```

### Page Switching Strategy

Pages automatically switch based on focused control type:

| Control Type | StreamDeck Page |
|--------------|-----------------|
| Button, CheckBox, ComboBox | Navigation (4-way) |
| Vertical Slider | UpDown (2-way) |
| Horizontal Slider | Slider (2-way horizontal) |
| DoubleSlider | DoubleSlider (4-way) |
| RoundSlider | RoundSlider (4-way) |

---

## Implementation Details

### Icon Management

**Icon Discovery:**
```csharp
// Icons stored in: <CM>\Assets\SDIcons\*.png
var icons = SDPIconHelper.DiscoverIcons();
// Returns: ["Back" ? "C:\CM\Assets\SDIcons\Back.png", ...]
```

**Icon Specifications:**
- **Absolute Path**: `C:\CM\Assets\SDIcons\Back.png`
- **Text Icon**: `!M` (generates icon with text "M")
- **Base64**: `data:image/png;base64,...`
- **Null**: Title-only key, no icon

### Page Layout

**Standard Layout (5x3 grid):**
```
Row 0: [Back] [WriteModalFilter] [WriteElementFilter]
Row 1: [null] [null]             [null]
Row 2: [null] [Up]               [null]
Row 3: [Left] [MouseLeft]        [Right]
Row 4: [null] [Down]             [null]
```

**Slider Layout:**
```
Row 0: [Back] [WriteModalFilter] [WriteElementFilter]
Row 1: [null] [null]             [null]
Row 2: [null] [null]             [null]
Row 3: [Left] [MouseLeft]        [Right]
Row 4: [null] [null]             [null]
```

### Path Filtering

**Excluded Paths:**
- `ContentFrame:ModernFrame` - Main navigation frame
- `*:ModernTabSplitter` - Visual separators
- Deep nested frames (complex layouts)

**Inclusion Rules:**
- Interactive controls (Button, Slider, CheckBox, etc.)
- Groups with navigable children (Menu, ListBox)
- Modal windows and dialogs

### Connection Lifecycle

```
???????????????????????????????????????????????????
?  1. Application Startup                         ?
?     - Navigator.Initialize()                    ?
?     - SDPClient constructed (watchdog starts)   ?
?     - ConnectAsync() attempts connection        ?
???????????????????????????????????????????????????
                    ?
???????????????????????????????????????????????????
?  2. Connection Established                      ?
?     - ReplicateStateToPluginAsync() runs        ?
?     - Keys, pages, current page sent            ?
?     - State synced ?                            ?
???????????????????????????????????????????????????
                    ?
???????????????????????????????????????????????????
?  3. Runtime Operation                           ?
?     - KeyPressed events ? Navigator actions     ?
?     - UI changes ? page switches                ?
?     - Watchdog monitors connection health       ?
???????????????????????????????????????????????????
                    ?
???????????????????????????????????????????????????
?  4. Disconnection Detected                      ?
?     - Watchdog triggers reconnection            ?
?     - Exponential backoff: 1s, 2s, 5s, 5s...   ?
?     - State replicated on reconnect             ?
???????????????????????????????????????????????????
                    ?
???????????????????????????????????????????????????
?  5. Application Shutdown                        ?
?     - Dispose() called                          ?
?     - Resources cleaned up gracefully           ?
?     - No exceptions thrown during finalization  ?
???????????????????????????????????????????????????
```

---

## Error Handling & Reliability

### Resilience Patterns

**1. Automatic Reconnection**
```csharp
// Exponential backoff with cap
int[] retryDelays = { 1000, 2000, 5000 };  // 1s, 2s, 5s, then 5s forever
```

**2. State Preservation**
```csharp
// State never lost, only replica sync status changes
_keys, _pages, _currentPage  // Always preserved
_isReplicaSynced = false;    // Triggers resync on reconnect
```

**3. Exception Suppression**
```csharp
// Finalizer NEVER throws exceptions
~SDPClient()
{
    try { Dispose(); }
    catch { /* Suppressed */ }
}
```

**4. User Notifications**
```csharp
// Toast notifications for connection status
// - Connected: "StreamDeck Connected - UI Navigation ready"
// - Disconnected: "StreamDeck Disconnected - Attempting to reconnect..."
// - Reconnecting: "StreamDeck Reconnecting - Attempt N"
```

**5. Development Fallback (DEBUG Only)**
```csharp
#if DEBUG
// Keyboard navigation available for development/testing
// Disabled in release builds - StreamDeck is mandatory
#endif
```

### StreamDeck Requirement Model

**StreamDeck is MANDATORY but RESILIENT:**

- ? **Required**: StreamDeck hardware + plugin must be present for navigation
- ? **Resilient**: Automatic reconnection handles transient failures
- ? **Non-Blocking**: Application continues running during disconnections
- ? **User-Informed**: Toast notifications keep user aware of status
- ? **No Fallback**: Keyboard navigation only in DEBUG builds

**Philosophy:**
- StreamDeck disconnection is treated as **temporary equipment failure**
- App continues running but navigation is unavailable
- Automatic recovery when StreamDeck becomes available again
- User is informed but not blocked

### Error Recovery Scenarios

| Scenario | Handling |
|----------|----------|
| Plugin not running at CM startup | Watchdog retries connection indefinitely, Toast shown |
| Plugin crashes during operation | Automatic reconnection + state replication, Toast notification |
| Named pipe write fails | Disconnect ? Reconnect ? Replicate, Toast updates |
| CM shutdown during connection | All disposals wrapped in try-catch, no exceptions |
| Page ordering circular dependency | Warning logged, pages sent anyway |
| Missing icon file | Plugin falls back to text rendering |
| Undefined key in page | Page definition rejected (fail-fast) |
| StreamDeck device unplugged | Connection lost ? reconnect when replugged, Toast shown |
| Multiple reconnect failures | Toast shown every 5 attempts to avoid spam |

### Debug Logging

All components use `Debug.WriteLine()` with prefixes:

```
[Navigator] Switching StreamDeck to 'Slider' page for modal 'Window:MainWindow:7910CA'
[Navigator] StreamDeck connected event received
[SDPClient] Connected successfully
[SDPClient] Replicating state: 9 keys, 5 pages
[SDPClient] ? Replicated 9 keys
[SDPClient] ? Replicated 5 pages
[SDPClient] ? Switched to page: Navigation
[SDPClient] ? Replication complete
```

### User-Visible Notifications

**Toast Notification Strategy:**
1. **Initial Connection Success**: Toast shown once
2. **Disconnection**: Toast shown immediately
3. **Reconnection Attempts**: Toast every 5 attempts (1, 5, 10, 15...)
4. **Reconnection Success**: Toast shown
5. **Duration**: 5 seconds (system default)
6. **Platform**: Windows 8+ native or system tray fallback

---

## Performance Considerations

### Connection Overhead

- **Initial Connection**: ~50-100ms for pipe connection
- **State Replication**: ~100-200ms for 9 keys + 5 pages
- **Reconnection**: 1-5 seconds (exponential backoff)

### Memory Footprint

- **NavGraph**: ~10KB for typical window (50-100 nodes)
- **SDPClient State**: <1KB (key/page definitions)
- **Named Pipe Buffer**: 4KB default

### CPU Usage

- **Idle**: Near zero (watchdog timer every 5s)
- **Navigation**: <1ms per keystroke
- **UI Sync**: ~5-10ms for full tree sync

### Optimization Strategies

1. **Lazy Initialization**: Navigator not created until first use
2. **Incremental Updates**: Only modified nodes re-synced
3. **Batched Commands**: Queue commands, send together
4. **Icon Caching**: Icons discovered once at startup
5. **Filtered Discovery**: Excluded paths skip traversal

---

## Testing Strategy

### Unit Testing

**NavNode Tests:**
- Hierarchy construction
- Property calculations (IsNavigable, IsModal, etc.)
- Bounds computation

**NavGraph Tests:**
- Tree building from XAML
- Path filtering
- Scope resolution

**SDPClient Tests:**
- State management (keys, pages)
- Command serialization
- Page dependency ordering

### Integration Testing

**End-to-End Scenarios:**

1. **Cold Start**
   - Start CM with plugin already running
   - Verify connection + state replication
   - Verify page switch to "Navigation"

2. **Plugin Restart**
   - CM running, kill plugin, restart plugin
   - Verify automatic reconnection
   - Verify state replication
   - Verify current page restored

3. **CM Restart**
   - Plugin running, restart CM
   - Verify connection established
   - Verify state defined
   - Verify navigation works

4. **Navigation Flow**
   - Open dialog ? verify page switch
   - Navigate to slider ? verify page switch
   - Close dialog ? verify page restore
   - Press StreamDeck buttons ? verify actions

### Manual Testing Checklist

- [ ] StreamDeck buttons show correct icons
- [ ] Navigation responds to StreamDeck input
- [ ] Page switching matches control type
- [ ] Modal dialogs restrict navigation scope
- [ ] Reconnection works after plugin crash
- [ ] No exceptions during CM shutdown
- [ ] **Toast notification shown on connection**
- [ ] **Toast notification shown on disconnection**
- [ ] **Toast notification shown during reconnection (every 5 attempts)**
- [ ] **Toast notification shown on reconnection success**
- [ ] **Keyboard navigation only works in DEBUG builds**
- [ ] **Keyboard navigation disabled in RELEASE builds**
- [ ] **Application continues running when StreamDeck disconnected**
- [ ] **Navigation resumes automatically after reconnection**

---

## Future Enhancements

### Phase 2 Features

1. **Dynamic Key Updates** (`SetKeyVisuals`)
   - Update key title/icon without redefining
   - Show live values (speed, fuel, etc.)
   - Status indicators on StreamDeck

2. **Virtual Keyboard**
   - Text input via StreamDeck
   - Filter text entry
   - Search functionality

3. **Profile Switching** (`SwitchProfile`)
   - Game-specific StreamDeck profiles
   - Automatic switching on game launch
   - Profile stack for nested contexts

4. **Telemetry Integration**
   - Display lap times on StreamDeck
   - Show gear/speed/RPM
   - Alert notifications

### Phase 3 Features

1. **Multiple StreamDecks**
   - Support multiple devices simultaneously
   - Dedicated pages for different functions
   - Coordinated state across devices

2. **Custom Scripting**
   - User-defined button actions
   - Macro recording/playback
   - Event-driven automation

3. **Plugin Marketplace**
   - User-created page layouts
   - Downloadable icon packs
   - Shared configurations

---

## Appendix A: File Organization

```
AcManager/
??? UiObserver/
?   ??? Navigator.cs            # Core navigation engine
?   ??? Navigator.SD.cs         # StreamDeck integration
?   ??? NavNode.cs              # Navigation node wrapper
?   ??? NavGraph.cs             # Navigation graph builder
?   ??? SDPClient.cs            # Named pipe client + state replication
?   ??? PathFilter.cs           # Path filtering rules
?
??? Assets/
    ??? SDIcons/                # StreamDeck button icons
        ??? Back.png
        ??? Up.png
        ??? Down.png
        ??? Left.png
        ??? Right.png
        ??? Mouse Left.png
        ??? Mouse Right.png
        ??? Close.png
```

---

## Appendix B: Key Classes

### SDPKeyDef
```csharp
public class SDPKeyDef
{
    public string KeyName { get; set; }
    public string Title { get; set; }
    public string IconSpec { get; set; }
}
```

### SDPPageDef
```csharp
public class SDPPageDef
{
    public string PageName { get; set; }
    public string[][] KeyGrid { get; set; }  // 5x3 grid
}
```

### NavNode
```csharp
public class NavNode
{
    public UIElement Element { get; }
    public NavNode Parent { get; set; }
    public List<NavNode> Children { get; }
    public bool IsGroup { get; }
    public bool IsModal { get; }
    public bool IsNavigable { get; }
    public Rect BoundsOnScreen { get; }
}
```

---

## Appendix C: Protocol State Machine

```
           ???????????????????
           ?  Disconnected   ?
           ???????????????????
                    ? ConnectAsync()
                    ?
           ???????????????????
           ?   Connecting    ?
           ???????????????????
                    ? Pipe.IsConnected
                    ?
           ???????????????????
           ?    Connected    ?
           ???????????????????
                    ? ReplicateState()
                    ?
           ???????????????????
           ?  Replicating    ?
           ???????????????????
                    ? Keys ? Pages ? CurrentPage
                    ?
           ???????????????????
           ?     Synced      ???????
           ???????????????????     ?
                    ?               ?
                    ? DefineKey()   ?
                    ? DefinePage()  ?
                    ? SwitchPage()  ?
                    ?????????????????
                    ?
                    ? Connection Lost
                    ?
           ???????????????????
           ?  Reconnecting   ?
           ???????????????????
                    ? Backoff: 1s, 2s, 5s...
                    ??????????? (back to Connecting)
```

---

## Document Revision History

| Version | Date | Author | Changes |
|---------|------|--------|---------|
| 1.0 | Dec 2024 | Initial | Initial design document |

---

**End of Document**
